From 6e31d6c5f0de914b9e864874863dcf2e9650c80e Mon Sep 17 00:00:00 2001
From: mkrsym1 <mkrsym1@gmail.com>
Date: Mon, 12 Jan 2026 00:12:53 +0100
Subject: [PATCH 06/11] ntdll: Avoid threadpool deadlock on process
 termination.

---
 dlls/ntdll/loader.c     | 5 ++++-
 dlls/ntdll/threadpool.c | 7 ++++++-
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 50d21e2d366..d8e1bf70a3d 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -94,7 +94,6 @@ static const WCHAR system_path[] = L"C:\\windows\\system32;C:\\windows\\system;C
 
 static BOOL is_prefix_bootstrap;  /* are we bootstrapping the prefix? */
 static BOOL imports_fixup_done = FALSE;  /* set once the imports have been fixed up, before attaching them */
-static BOOL process_detaching = FALSE;  /* set on process detach to avoid deadlocks with thread detach */
 static int free_lib_count;   /* recursion depth of LdrUnloadDll calls */
 static LONG path_safe_mode;  /* path mode set by RtlSetSearchPathMode */
 static LONG dll_safe_mode = 1;  /* dll search mode */
@@ -104,6 +103,10 @@ static DWORD default_search_flags;  /* default flags set by LdrSetDefaultDllDire
 static WCHAR *default_load_path;    /* default dll search path */
 static HANDLE known_dlls_ntdir;  /* NT directory containing known dlls sections */
 
+/* set on process detach to avoid deadlocks with thread detach 
+ * needs to be non-static to avoid deadlock in threadpool.c (bug 59178) */
+BOOL process_detaching = FALSE;  
+
 struct dll_dir_entry
 {
     struct list entry;
diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 4f707bdd782..d2ee0832cea 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -34,6 +34,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(threadpool);
 
+/* from loader.c, to avoid deadlock (bug 59178) */
+extern BOOL process_detaching;
+
 /*
  * Old thread pooling API
  */
@@ -2083,7 +2086,9 @@ static void tp_object_wait( struct threadpool_object *object, BOOL group_wait )
     struct threadpool *pool = object->pool;
 
     RtlEnterCriticalSection( &pool->cs );
-    while (!object_is_finished( object, group_wait ))
+    /* if process is detaching, then all other threads are dead
+     * so this wait will be infinite (bug 59178) */
+    while (!process_detaching && !object_is_finished( object, group_wait ))
     {
         if (group_wait)
             RtlSleepConditionVariableCS( &object->group_finished_event, &pool->cs, NULL );
-- 
2.52.0

