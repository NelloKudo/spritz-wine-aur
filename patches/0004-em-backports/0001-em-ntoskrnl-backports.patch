diff --git a/dlls/ntoskrnl.exe/instr.c b/dlls/ntoskrnl.exe/instr.c
index 03f48152b94..144c17adfbd 100644
--- a/dlls/ntoskrnl.exe/instr.c
+++ b/dlls/ntoskrnl.exe/instr.c
@@ -22,6 +22,7 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -480,7 +481,13 @@ WINE_DEFAULT_DEBUG_CHANNEL(int);
 #define REX_R   4
 #define REX_W   8
 
-#define MSR_LSTAR   0xc0000082
+#define MSR_DEBUGCTL    0x1d9
+#define MSR_HYPERV      0x40000000
+#define MSR_HYPERV2     0x40000001
+#define MSR_KVM         0x4b564d00
+#define MSR_LSTAR       0xc0000082
+
+#define VMW_PORT        0x5658
 
 #define REGMODRM_MOD( regmodrm, rex )   ((regmodrm) >> 6)
 #define REGMODRM_REG( regmodrm, rex )   (((regmodrm) >> 3) & 7) | (((rex) & REX_R) ? 8 : 0)
@@ -732,10 +739,10 @@ static DWORD emulate_instruction( EXCEPTION_RECORD *rec, CONTEXT *context )
             TRACE( "mov cr%u,%s at %Ix\n", reg, reg_names[rm], context->Rip );
             switch (reg)
             {
-            case 0: *data = 0x10; break; /* FIXME: set more bits ? */
+            case 0: *data = CR0_PE|CR0_ET|CR0_NE|CR0_WP|CR0_AM|CR0_PG; break;
             case 2: *data = 0; break;
             case 3: *data = 0; break;
-            case 4: *data = 0; break;
+            case 4: *data = 0x20; break;
             case 8: *data = 0; break;
             default: return ExceptionContinueSearch;
             }
@@ -815,6 +822,20 @@ static DWORD emulate_instruction( EXCEPTION_RECORD *rec, CONTEXT *context )
                 context->Rax = (ULONG)syscall_address;
                 break;
             }
+            case MSR_HYPERV:
+            case MSR_HYPERV2:
+            case MSR_KVM:
+            {
+                /* we are not a VM */
+                return ExceptionContinueSearch;
+            }
+            case MSR_DEBUGCTL:
+            {
+                TRACE("MSR_DEBUGCTL, returning 0.\n");
+                context->Rdx = 0;
+                context->Rax = 0;
+                break;
+            }
             default:
                 FIXME("reg %#lx, returning 0.\n", reg);
                 context->Rdx = 0;
@@ -902,7 +923,30 @@ static DWORD emulate_instruction( EXCEPTION_RECORD *rec, CONTEXT *context )
         }
         break;  /* Unable to emulate it */
     }
+    case 0xed: /* inl eAX, DX */
+    {
+        static const char *env;
+        WORD port = context->Rdx & 0xffff;
+ 
+        if (!env) env = getenv("WINE_EMULATE_CONTEXT");
 
+        switch (port)
+        {
+            /* we are not a VM! */
+            case VMW_PORT:
+                context->Rax = 0;
+                if (env)
+                {
+                    context->Rbx = 0;
+                    context->Rcx = 0;
+                }
+                context->Rip += prefixlen + 1;
+                return ExceptionContinueExecution;
+            default:
+                FIXME("Unkown port %#x!\n", port);
+                return ExceptionContinueSearch;
+        }
+    }
     case 0xfa: /* cli */
     case 0xfb: /* sti */
         context->Rip += prefixlen + 1;
diff --git a/dlls/ntoskrnl.exe/ntoskrnl.c b/dlls/ntoskrnl.exe/ntoskrnl.c
index a15de6d1b95..3d30b8c8048 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/ntoskrnl.c
@@ -258,6 +258,12 @@ POBJECT_TYPE WINAPI ObGetObjectType( void *object )
     return header->type;
 }
 
+static struct _OBJECT_TYPE section_type =
+{
+    {},
+    RTL_CONSTANT_STRING( L"Section" )
+};
+
 static const POBJECT_TYPE *known_types[] =
 {
     &ExEventObjectType,
@@ -267,7 +273,8 @@ static const POBJECT_TYPE *known_types[] =
     &IoFileObjectType,
     &PsProcessType,
     &PsThreadType,
-    &SeTokenObjectType
+    &SeTokenObjectType,
+    &section_type,
 };
 
 DECLARE_CRITICAL_SECTION(handle_map_cs);
@@ -311,8 +318,7 @@ NTSTATUS kernel_object_from_handle( HANDLE handle, POBJECT_TYPE type, void **ret
             for (i = 0; i < ARRAY_SIZE(known_types); i++)
             {
                 type = *known_types[i];
-                if (!RtlCompareUnicodeStrings( type->name, lstrlenW(type->name), type_info->TypeName.Buffer,
-                                               type_info->TypeName.Length / sizeof(WCHAR), FALSE ))
+                if (!RtlCompareUnicodeString( &type->name, &type_info->TypeName, FALSE ))
                     break;
             }
             if (i == ARRAY_SIZE(known_types))
@@ -322,8 +328,7 @@ NTSTATUS kernel_object_from_handle( HANDLE handle, POBJECT_TYPE type, void **ret
                 return STATUS_INVALID_HANDLE;
             }
         }
-        else if (RtlCompareUnicodeStrings( type->name, lstrlenW(type->name), type_info->TypeName.Buffer,
-                                           type_info->TypeName.Length / sizeof(WCHAR), FALSE) )
+        else if (RtlCompareUnicodeString( &type->name, &type_info->TypeName, FALSE) )
         {
             LeaveCriticalSection( &handle_map_cs );
             return STATUS_OBJECT_TYPE_MISMATCH;
@@ -333,7 +338,7 @@ NTSTATUS kernel_object_from_handle( HANDLE handle, POBJECT_TYPE type, void **ret
             obj = type->constructor( handle );
         else
         {
-            FIXME( "No constructor for type %s\n", debugstr_w(type->name) );
+            FIXME( "No constructor for type %s\n", debugstr_us(&type->name) );
             obj = alloc_kernel_object( type, handle, 0, 0 );
         }
         if (!obj) status = STATUS_NO_MEMORY;
@@ -405,10 +410,9 @@ NTSTATUS WINAPI ObOpenObjectByPointer( void *obj, ULONG attr, ACCESS_STATE *acce
 
 static void *create_file_object( HANDLE handle );
 
-static const WCHAR file_type_name[] = {'F','i','l','e',0};
-
 static struct _OBJECT_TYPE file_type = {
-    file_type_name,
+    {},
+    RTL_CONSTANT_STRING( L"File" ),
     create_file_object
 };
 
@@ -1520,11 +1524,10 @@ static void free_driver_object( void *obj )
     free_kernel_object( driver );
 }
 
-static const WCHAR driver_type_name[] = {'D','r','i','v','e','r',0};
-
 static struct _OBJECT_TYPE driver_type =
 {
-    driver_type_name,
+    {},
+    RTL_CONSTANT_STRING( L"Driver" ),
     NULL,
     free_driver_object
 };
@@ -1598,11 +1601,10 @@ void WINAPI IoDeleteDriver( DRIVER_OBJECT *driver_object )
 }
 
 
-static const WCHAR device_type_name[] = {'D','e','v','i','c','e',0};
-
 static struct _OBJECT_TYPE device_type =
 {
-    device_type_name,
+    {},
+    RTL_CONSTANT_STRING( L"Device" )
 };
 
 POBJECT_TYPE IoDeviceObjectType = &device_type;
@@ -2122,7 +2124,7 @@ BOOLEAN WINAPI IoCancelIrp( IRP *irp )
     irp->Cancel = TRUE;
     if (!(cancel_routine = IoSetCancelRoutine( irp, NULL )))
     {
-        IoReleaseCancelSpinLock( irql );
+        IoReleaseCancelSpinLock( irp->CancelIrql );
         return FALSE;
     }
 
@@ -2454,22 +2456,60 @@ NTSTATUS WINAPI FsRtlRegisterUncProvider(PHANDLE MupHandle, PUNICODE_STRING Redi
 
 static void *create_process_object( HANDLE handle )
 {
+    char *p;
+    ULONG len;
+    HANDLE token;
     PEPROCESS process;
+    ANSI_STRING fullImageNameA;
+    UNICODE_STRING *fullImageNameW = NULL;
 
     if (!(process = alloc_kernel_object( PsProcessType, handle, sizeof(*process), 0 ))) return NULL;
 
     process->header.Type = 3;
     process->header.WaitListHead.Blink = INVALID_HANDLE_VALUE; /* mark as kernel object */
     NtQueryInformationProcess( handle, ProcessBasicInformation, &process->info, sizeof(process->info), NULL );
+    NtQueryInformationProcess( handle, ProcessSessionInformation, &process->session_id, sizeof(process->session_id), NULL );
+    NtQueryInformationProcess( handle, ProcessTimes, &process->times, sizeof(process->times), NULL );
+
+    /* get full image name */
+    NtQueryInformationProcess( handle, ProcessImageFileNameWin32, fullImageNameW, 0, &len );
+    fullImageNameW = calloc(len + 1, sizeof(WCHAR));
+    if (fullImageNameW)
+    {
+        fullImageNameW->MaximumLength = len + sizeof(WCHAR);
+        NtQueryInformationProcess( handle, ProcessImageFileNameWin32, fullImageNameW, len, &len );
+        if (fullImageNameW->Buffer)
+        {
+            RtlUnicodeStringToAnsiString(&fullImageNameA, fullImageNameW, TRUE);
+            if (fullImageNameA.Buffer)
+            {
+                /* generate short name */
+                for (p = fullImageNameA.Buffer + fullImageNameA.Length - 1; p > fullImageNameA.Buffer; p--)
+                {
+                    if (*(p-1) == '\\') break;
+                }
+                memcpy(process->imageName, p,
+                       min(fullImageNameA.Buffer + fullImageNameA.Length - p,
+                           sizeof(process->imageName)));
+                RtlFreeAnsiString(&fullImageNameA);
+            }
+        }
+        free(fullImageNameW);
+    }
+
     IsWow64Process( handle, &process->wow64 );
+
+    NtOpenProcessToken( handle, TOKEN_ALL_ACCESS, &token );
+    kernel_object_from_handle( token, SeTokenObjectType, &process->token );
+    NtClose( token );
+
     return process;
 }
 
-static const WCHAR process_type_name[] = {'P','r','o','c','e','s','s',0};
-
 static struct _OBJECT_TYPE process_type =
 {
-    process_type_name,
+    {},
+    RTL_CONSTANT_STRING( L"Process" ),
     create_process_object
 };
 
@@ -2512,6 +2552,15 @@ HANDLE WINAPI PsGetProcessId(PEPROCESS process)
     return (HANDLE)process->info.UniqueProcessId;
 }
 
+/*********************************************************************
+ *           PsGetProcessPeb    (NTOSKRNL.@)
+ */
+PEB *WINAPI PsGetProcessPeb(PEPROCESS process)
+{
+    TRACE( "%p -> %p\n", process, process->info.PebBaseAddress );
+    return process->info.PebBaseAddress;
+}
+
 /*********************************************************************
  *           PsGetProcessInheritedFromUniqueProcessId  (NTOSKRNL.@)
  */
@@ -2522,6 +2571,70 @@ HANDLE WINAPI PsGetProcessInheritedFromUniqueProcessId( PEPROCESS process )
     return id;
 }
 
+/*********************************************************************
+ *           PsGetProcessSessionId    (NTOSKRNL.@)
+ */
+ULONG WINAPI PsGetProcessSessionId( PEPROCESS process )
+{
+    TRACE("%p -> %lu\n", process, process->session_id);
+    return process->session_id;
+}
+
+/*********************************************************************
+ *           PsGetProcessCreateTimeQuadPart    (NTOSKRNL.@)
+ */
+LONGLONG WINAPI PsGetProcessCreateTimeQuadPart( PEPROCESS process )
+{
+    TRACE("%p -> %I64x\n", process, process->times.CreateTime.QuadPart);
+    return process->times.CreateTime.QuadPart;
+}
+
+/*********************************************************************
+ *           PsGetProcessExitStatus    (NTOSKRNL.@)
+ */
+NTSTATUS WINAPI PsGetProcessExitStatus( PEPROCESS process )
+{
+    PROCESS_BASIC_INFORMATION info;
+    HANDLE handle, id = PsGetProcessId(process);
+
+    if (!(handle = OpenProcess( PROCESS_ALL_ACCESS, FALSE, HandleToUlong(id) )))
+        return STATUS_SUCCESS;
+
+    NtQueryInformationProcess(handle, ProcessBasicInformation,
+                              &info, sizeof(info), NULL);
+    NtClose(handle);
+    TRACE("%p -> %lx\n", process, info.ExitStatus);
+    return info.ExitStatus;
+}
+
+/*********************************************************************
+ *           PsGetProcessExitProcessCalled    (NTOSKRNL.@)
+ */
+BOOL WINAPI PsGetProcessExitProcessCalled( PEPROCESS process )
+{
+    /* FIXME: not quite accurate */
+    return PsGetProcessExitStatus(process) != STATUS_PENDING;
+}
+
+/*********************************************************************
+ *           PsGetProcessImageFileName    (NTOSKRNL.@)
+ */
+const char *WINAPI PsGetProcessImageFileName( PEPROCESS process )
+{
+    TRACE("%p -> %s\n", process, debugstr_an(process->imageName, sizeof(process->imageName)));
+    return process->imageName;
+}
+
+/*********************************************************************
+ *           PsReferencePrimaryToken    (NTOSKRNL.@)
+ */
+PACCESS_TOKEN WINAPI PsReferencePrimaryToken( PEPROCESS process )
+{
+    TRACE("%p -> %p\n", process, process->token);
+    ObReferenceObject(process->token);
+    return process->token;
+}
+
 static void *create_thread_object( HANDLE handle )
 {
     THREAD_BASIC_INFORMATION info;
@@ -2548,11 +2661,10 @@ static void *create_thread_object( HANDLE handle )
     return thread;
 }
 
-static const WCHAR thread_type_name[] = {'T','h','r','e','a','d',0};
-
 static struct _OBJECT_TYPE thread_type =
 {
-    thread_type_name,
+    {},
+    RTL_CONSTANT_STRING( L"Thread" ),
     create_thread_object
 };
 
@@ -2616,6 +2728,15 @@ HANDLE WINAPI PsGetThreadId(PETHREAD thread)
     return thread->kthread.id.UniqueThread;
 }
 
+/*********************************************************************
+ *           PsGetThreadProcess    (NTOSKRNL.@)
+ */
+PEPROCESS WINAPI PsGetThreadProcess(PETHREAD thread)
+{
+    TRACE("%p -> %p\n", thread, thread->kthread.process);
+    return thread->kthread.process;
+}
+
 /*********************************************************************
  *           PsGetThreadProcessId    (NTOSKRNL.@)
  */
@@ -2799,6 +2920,67 @@ void WINAPI KeRevertToUserAffinityThreadEx(KAFFINITY affinity)
     thread->user_affinity = affinity;
 }
 
+/* FIXME: move these */
+
+typedef enum _KBUGCHECK_CALLBACK_REASON {
+    KbCallbackInvalid,
+    KbCallbackReserved1,
+    KbCallbackSecondaryDumpData,
+    KbCallbackDumpIo,
+    KbCallbackAddPages,
+    KbCallbackSecondaryMultiPartDumpData,
+    KbCallbackRemovePages,
+    KbCallbackTriageDumpData,
+    KbCallbackReserved2,
+    KbCallbackReserved3
+} KBUGCHECK_CALLBACK_REASON;
+
+typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
+    LIST_ENTRY                         Entry;
+    PVOID                              CallbackRoutine;
+    PUCHAR                             Component;
+    ULONG_PTR                          Checksum;
+    KBUGCHECK_CALLBACK_REASON          Reason;
+    UCHAR                              State;
+} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;
+
+/***********************************************************************
+ *           KeRegisterBugCheckCallback   (NTOSKRNL.EXE.@)
+ */
+BOOL WINAPI KeRegisterBugCheckCallback(void *record, void *routine,
+                                       void *buffer, ULONG length, char *component)
+{
+    FIXME("%p %p %p %lu %s stub!\n", record, routine, buffer, length, debugstr_a(component));
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           KeRegisterBugCheckReasonCallback    (NTOSKRNL.@)
+ */
+BOOLEAN WINAPI KeRegisterBugCheckReasonCallback(KBUGCHECK_REASON_CALLBACK_RECORD *record,
+                                                void *routine, KBUGCHECK_CALLBACK_REASON reason,
+                                                UCHAR *component)
+{
+    FIXME("%p %p %x %p stub!\n", record, routine, reason, component);
+
+    record->CallbackRoutine = routine;
+    record->Reason = reason;
+    record->Component = component;
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           KeDeregisterBugCheckReasonCallback   (NTOSKRNL.EXE.@)
+ */
+BOOL WINAPI KeDeregisterBugCheckReasonCallback(void *record)
+{
+    FIXME("%p stub!\n", record);
+
+    return TRUE;
+}
+
 /***********************************************************************
  *           IoRegisterFileSystem   (NTOSKRNL.EXE.@)
  */
@@ -2935,6 +3117,37 @@ PHYSICAL_ADDRESS WINAPI MmGetPhysicalAddress(void *virtual_address)
     return ret;
 }
 
+/***********************************************************************
+ *           MmGetPhysicalMemoryRanges   (NTOSKRNL.EXE.@)
+ */
+PHYSICAL_MEMORY_RANGE *WINAPI MmGetPhysicalMemoryRanges(void)
+{
+    static volatile LONG once;
+    static PHYSICAL_MEMORY_RANGE range;
+    SYSTEM_BASIC_INFORMATION info;
+
+    TRACE("\n");
+
+    if (!InterlockedCompareExchange(&once, 1, 0))
+    {
+        NtQuerySystemInformation(SystemBasicInformation, &info, sizeof(info), NULL);
+        range.BaseAddress.QuadPart = info.MmLowestPhysicalPage;
+        range.NumberOfBytes.QuadPart = (ULONG64)info.MmNumberOfPhysicalPages * (ULONG64)info.PageSize;
+    }
+
+    return &range;
+}
+
+/***********************************************************************
+ *           MmGetVirtualForPhysical   (NTOSKRNL.EXE.@)
+ */
+void *WINAPI MmGetVirtualForPhysical(PHYSICAL_ADDRESS addr)
+{
+    ULONG_PTR ret = addr.QuadPart;
+    FIXME("(%p): semi-stub!\n", (void *)ret);
+    return (void *)ret;
+}
+
 /***********************************************************************
  *           MmMapIoSpace   (NTOSKRNL.EXE.@)
  */
@@ -3050,17 +3263,17 @@ NTSTATUS WINAPI ObReferenceObjectByName( UNICODE_STRING *ObjectName,
                                          void *ParseContext,
                                          void **Object)
 {
+    NTSTATUS ret = STATUS_SUCCESS;
     struct wine_driver *driver;
     struct wine_rb_entry *entry;
 
-    TRACE("mostly-stub:%s %li %p %li %p %i %p %p\n", debugstr_us(ObjectName),
+    TRACE("%s %li %p %li %p %i %p %p\n", debugstr_us(ObjectName),
         Attributes, AccessState, DesiredAccess, ObjectType, AccessMode,
         ParseContext, Object);
 
     if (AccessState) FIXME("Unhandled AccessState\n");
     if (DesiredAccess) FIXME("Unhandled DesiredAccess\n");
     if (ParseContext) FIXME("Unhandled ParseContext\n");
-    if (ObjectType) FIXME("Unhandled ObjectType\n");
 
     if (AccessMode != KernelMode)
     {
@@ -3068,18 +3281,49 @@ NTSTATUS WINAPI ObReferenceObjectByName( UNICODE_STRING *ObjectName,
         return STATUS_NOT_IMPLEMENTED;
     }
 
-    EnterCriticalSection(&drivers_cs);
-    entry = wine_rb_get(&wine_drivers, ObjectName);
-    LeaveCriticalSection(&drivers_cs);
-    if (!entry)
+    
+    if (!ObjectType || !Object || !ObjectName) return STATUS_INVALID_PARAMETER;
+
+    *Object = NULL;
+
+    if (!RtlCompareUnicodeString(&ObjectType->name, &IoDriverObjectType->name, FALSE))
     {
-        FIXME("Object (%s) not found, may not be tracked.\n", debugstr_us(ObjectName));
-        return STATUS_NOT_IMPLEMENTED;
+        EnterCriticalSection(&drivers_cs);
+        entry = wine_rb_get(&wine_drivers, ObjectName);
+        LeaveCriticalSection(&drivers_cs);
+        if (!entry)
+        {
+            FIXME("Object (%s) not found, may not be tracked.\n", debugstr_us(ObjectName));
+            return STATUS_NOT_FOUND;
+        }
+
+        driver = WINE_RB_ENTRY_VALUE(entry, struct wine_driver, entry);
+        ObReferenceObject( *Object = &driver->driver_obj );
+    } else {
+
+        SERVER_START_REQ(get_kernel_object_name)
+        {
+            req->manager = wine_server_obj_handle( get_device_manager() );
+            req->attributes = Attributes;
+            req->rootdir = 0;
+            wine_server_add_data(req, ObjectName->Buffer, ObjectName->Length);
+            if (!(ret = wine_server_call( req )))
+                *Object = wine_server_get_ptr( reply->user_ptr );
+        }
+        SERVER_END_REQ;
+
+        if (*Object)
+        {
+            if (ObGetObjectType( *Object ) != ObjectType)
+                ret = STATUS_OBJECT_TYPE_MISMATCH;
+            else
+                ObReferenceObject( *Object );
+        }
+
+        FIXME("ret %p %lx\n", *Object, ret);
     }
 
-    driver = WINE_RB_ENTRY_VALUE(entry, struct wine_driver, entry);
-    ObReferenceObject( *Object = &driver->driver_obj );
-    return STATUS_SUCCESS;
+    return ret;
 }
 
 
@@ -3188,6 +3432,14 @@ DEVICE_OBJECT* WINAPI IoGetAttachedDeviceReference( DEVICE_OBJECT *device )
     return result;
 }
 
+/***********************************************************************
+ *           IoGetBaseFileSystemDeviceObject   (NTOSKRNL.EXE.@)
+ */
+DEVICE_OBJECT *WINAPI IoGetBaseFileSystemDeviceObject( FILE_OBJECT *file )
+{
+    FIXME("%p -> %p semi-stub!\n", file, file->DeviceObject);
+    return file->DeviceObject;
+}
 
 /***********************************************************************
  *           PsCreateSystemThread   (NTOSKRNL.EXE.@)
@@ -3227,6 +3479,29 @@ HANDLE WINAPI PsGetCurrentThreadId(void)
     return KeGetCurrentThread()->id.UniqueThread;
 }
 
+/***********************************************************************
+ *           PsGetCurrentThreadTeb   (NTOSKRNL.EXE.@)
+ */
+TEB *WINAPI PsGetCurrentThreadTeb(void)
+{
+    return NtCurrentTeb();
+}
+
+/***********************************************************************
+ *           PsGetCurrentThreadProcess   (NTOSKRNL.EXE.@)
+ */
+PEPROCESS WINAPI PsGetCurrentThreadProcess(void)
+{
+    return KeGetCurrentThread()->process;
+}
+
+/***********************************************************************
+ *           PsGetCurrentThreadProcess   (NTOSKRNL.EXE.@)
+ */
+HANDLE WINAPI PsGetCurrentThreadProcessId(void)
+{
+    return PsGetProcessId(PsGetCurrentThreadProcess());
+}
 
 /***********************************************************************
  *           PsIsSystemThread   (NTOSKRNL.EXE.@)
@@ -3727,7 +4002,17 @@ void WINAPI KeBugCheckEx(ULONG code, ULONG_PTR param1, ULONG_PTR param2, ULONG_P
  */
 void WINAPI ProbeForRead(void *address, SIZE_T length, ULONG alignment)
 {
-    FIXME("(%p %Iu %lu) stub\n", address, length, alignment);
+    TRACE("(%p %Iu %lu)\n", address, length, alignment);
+
+    if (length == 0) return;
+
+    if ((ULONG_PTR)address & (alignment-1))
+        RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
+
+    if ((ULONG_PTR)address + length < (ULONG_PTR)address)
+        RtlRaiseStatus(STATUS_ACCESS_VIOLATION);
+
+    /* TODO: Check if within address space */
 }
 
 /***********************************************************************
@@ -3736,6 +4021,14 @@ void WINAPI ProbeForRead(void *address, SIZE_T length, ULONG alignment)
 void WINAPI ProbeForWrite(void *address, SIZE_T length, ULONG alignment)
 {
     FIXME("(%p %Iu %lu) stub\n", address, length, alignment);
+    TRACE("(%p %Iu %lu)\n", address, length, alignment);
+
+    if (length == 0) return;
+
+    ProbeForRead(address, length, alignment);
+
+    for (volatile char *p = address; p < (char *)address + length; p++)
+        *p |= 0;
 }
 
 /***********************************************************************
@@ -4296,9 +4589,43 @@ BOOLEAN WINAPI SePrivilegeCheck(PRIVILEGE_SET *privileges, SECURITY_SUBJECT_CONT
  */
 NTSTATUS WINAPI SeLocateProcessImageName(PEPROCESS process, UNICODE_STRING **image_name)
 {
-    FIXME("stub: %p %p\n", process, image_name);
-    if (image_name) *image_name = NULL;
-    return STATUS_NOT_IMPLEMENTED;
+    ULONG len;
+    NTSTATUS status;
+    HANDLE handle, id = PsGetProcessId(process);
+
+    TRACE("%p %p\n", process, image_name);
+
+    if (!image_name) return STATUS_INVALID_PARAMETER;
+
+    if (!(handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, HandleToUlong(id))))
+        return STATUS_NOT_FOUND;
+
+    NtQueryInformationProcess(handle, ProcessImageFileNameWin32, *image_name, 0, &len);
+
+    len += sizeof(WCHAR);
+
+    *image_name = ExAllocatePool(PagedPool, len);
+
+    if (!*image_name)
+    {
+        NtClose(handle);
+        return STATUS_NO_MEMORY;
+    }
+
+    (*image_name)->MaximumLength = len;
+
+    if ((status = NtQueryInformationProcess(handle, ProcessImageFileNameWin32,
+                                            *image_name, len - sizeof(WCHAR), &len)))
+    {
+        NtClose(handle);
+        return status;
+    }
+
+    TRACE("ret: %s\n", debugstr_us(*image_name));
+
+    NtClose(handle);
+
+    return STATUS_SUCCESS;
 }
 
 /*********************************************************************
@@ -4357,15 +4684,32 @@ void WINAPI KeLeaveGuardedRegion(void)
     FIXME("\n");
 }
 
-static const WCHAR token_type_name[] = {'T','o','k','e','n',0};
-
 static struct _OBJECT_TYPE token_type =
 {
-    token_type_name
+    {},
+    RTL_CONSTANT_STRING( L"Token" )
 };
 
 POBJECT_TYPE SeTokenObjectType = &token_type;
 
+NTSTATUS WINAPI SeQueryInformationToken(PACCESS_TOKEN token, TOKEN_INFORMATION_CLASS class, void **info)
+{
+    HANDLE handle;
+    NTSTATUS status;
+    /* FIXME: calculate size dynamically */
+    const ULONG size = 0x1000;
+    TRACE("%p %u %p\n", token, class, info);
+
+    if ((status = ObOpenObjectByPointer( token, OBJ_KERNEL_HANDLE, NULL, TOKEN_ALL_ACCESS, SeTokenObjectType, KernelMode, &handle )))
+        return status;
+
+    *info = ExAllocatePool(PagedPool, size);
+
+    if (!*info) return STATUS_NO_MEMORY;
+
+    return NtQueryInformationToken(handle, class, *info, size, NULL);
+}
+
 /*************************************************************************
  *           ExUuidCreate            (NTOSKRNL.@)
  *
@@ -4637,6 +4981,14 @@ void WINAPI KeUnstackDetachProcess(KAPC_STATE *apc_state)
     FIXME("apc_state %p stub.\n", apc_state);
 }
 
+NTSTATUS WINAPI KeCapturePersistentThreadState(CONTEXT *context, PKTHREAD thread, ULONG code,
+                                               ULONG param1, ULONG param2, ULONG param3, ULONG param4, void *addr)
+{
+    FIXME("%p %p %lu %lu %lu %lu %lu %p", context, thread, code, param1, param2, param3, param4, addr);
+
+    return STATUS_NOT_IMPLEMENTED;
+}
+
 NTSTATUS WINAPI KdDisableDebugger(void)
 {
     FIXME(": stub.\n");
@@ -4688,6 +5040,19 @@ NTSTATUS WINAPI EtwUnregister(REGHANDLE handle)
     return STATUS_SUCCESS;
 }
 
+BOOL WINAPI VslGetSecurePciEnabled(void)
+{
+    FIXME("stub!\n");
+    return TRUE;
+}
+
+static NTSTATUS WINAPI driver_stub( DRIVER_OBJECT *driver, UNICODE_STRING *path )
+{
+    FIXME("%p %s stub!\n", driver, debugstr_us(path));
+
+    return STATUS_SUCCESS;
+}
+
 /*****************************************************
  *           DllMain
  */
@@ -4695,6 +5060,9 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved )
 {
     static void *handler;
     LARGE_INTEGER count;
+    UNICODE_STRING str = RTL_CONSTANT_STRING( L"\\Driver\\pci" );
+    UNICODE_STRING hidusb = RTL_CONSTANT_STRING( L"\\Driver\\hidusb" );
+    UNICODE_STRING disk = RTL_CONSTANT_STRING( L"\\Driver\\Disk" );
 
     switch(reason)
     {
@@ -4708,6 +5076,9 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved )
         ntoskrnl_heap = HeapCreate( HEAP_CREATE_ENABLE_EXECUTE, 0, 0 );
         dpc_call_tls_index = TlsAlloc();
         LdrRegisterDllNotification( 0, ldr_notify_callback, NULL, &ldr_notify_cookie );
+        IoCreateDriver(&str, driver_stub);
+        IoCreateDriver(&hidusb, driver_stub);
+        IoCreateDriver(&disk, driver_stub);
         break;
     case DLL_PROCESS_DETACH:
         LdrUnregisterDllNotification( ldr_notify_cookie );
diff --git a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
index 4426e5066e0..fbb99fb259f 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
+++ b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
@@ -2,6 +2,7 @@
 @ stdcall EtwUnregister(int64)
 @ stdcall -arch=!i386 ExAcquireFastMutex(ptr)
 @ stdcall -fastcall ExAcquireFastMutexUnsafe(ptr)
+@ stub ExAcquirePushLockSharedEx
 @ stub ExAcquireRundownProtection
 @ stub ExAcquireRundownProtectionEx
 @ stub ExInitializeRundownProtection
@@ -13,6 +14,7 @@
 @ stub ExReInitializeRundownProtection
 @ stdcall -arch=!i386 ExReleaseFastMutex(ptr)
 @ stdcall -fastcall ExReleaseFastMutexUnsafe(ptr)
+@ stub ExReleasePushLockSharedEx
 @ stdcall -fastcall ExReleaseResourceLite(ptr)
 @ stub ExReleaseRundownProtection
 @ stub ExReleaseRundownProtectionEx
@@ -52,12 +54,16 @@
 @ stdcall -fastcall IofCompleteRequest(ptr long)
 @ stdcall -arch=!i386 KeAcquireInStackQueuedSpinLock(ptr ptr)
 @ stdcall -fastcall KeAcquireInStackQueuedSpinLockAtDpcLevel(ptr ptr)
+@ stdcall KeAcquireGuardedMutexUnsafe(ptr)
+@ stdcall KeAcquireGuardedMutex(ptr)
 @ stdcall KeEnterGuardedRegion()
 @ stdcall KeExpandKernelStackAndCallout(ptr ptr long)
 @ stdcall KeExpandKernelStackAndCalloutEx(ptr ptr long long ptr)
 @ stdcall KeLeaveGuardedRegion()
 @ stdcall -arch=!i386 KeReleaseInStackQueuedSpinLock(ptr)
 @ stdcall -fastcall KeReleaseInStackQueuedSpinLockFromDpcLevel(ptr)
+@ stdcall KeReleaseGuardedMutexUnsafe(ptr)
+@ stdcall KeReleaseGuardedMutex(ptr)
 @ stub KeSetTimeUpdateNotifyRoutine
 @ stub KefAcquireSpinLockAtDpcLevel
 @ stub KefReleaseSpinLockFromDpcLevel
@@ -76,6 +82,7 @@
 @ stub Kei386EoiHelper
 @ stub Kii386SpinOnSpinLock
 @ stub CcCanIWrite
+@ stub CcCoherencyFlushAndPurgeCache
 @ stub CcCopyRead
 @ stub CcCopyWrite
 @ stub CcDeferWrite
@@ -397,7 +404,7 @@
 @ stdcall IoFreeWorkItem(ptr)
 @ stdcall IoGetAttachedDevice(ptr)
 @ stdcall IoGetAttachedDeviceReference(ptr)
-@ stub IoGetBaseFileSystemDeviceObject
+@ stdcall IoGetBaseFileSystemDeviceObject(ptr)
 @ stub IoGetBootDiskInformation
 @ stdcall IoGetConfigurationInformation()
 @ stdcall IoGetCurrentProcess()
@@ -545,13 +552,13 @@
 @ stdcall KeBugCheck(long)
 @ stdcall KeBugCheckEx(long long long long long)
 @ stdcall KeCancelTimer(ptr)
-@ stub KeCapturePersistentThreadState
+@ stdcall KeCapturePersistentThreadState(ptr ptr long long long long long ptr)
 @ stdcall KeClearEvent(ptr)
 @ stub KeConnectInterrupt
 @ stub KeDcacheFlushCount
 @ stdcall KeDelayExecutionThread(long long ptr)
 @ stub KeDeregisterBugCheckCallback
-@ stub KeDeregisterBugCheckReasonCallback
+@ stdcall KeDeregisterBugCheckReasonCallback(ptr)
 @ stub KeDetachProcess
 @ stub KeDisconnectInterrupt
 @ stdcall KeEnterCriticalRegion()
@@ -625,8 +632,8 @@
 @ stub KeReadStateQueue
 @ stub KeReadStateSemaphore
 @ stub KeReadStateTimer
-@ stub KeRegisterBugCheckCallback
-@ stub KeRegisterBugCheckReasonCallback
+@ stdcall KeRegisterBugCheckCallback(ptr ptr ptr long ptr)
+@ stdcall KeRegisterBugCheckReasonCallback(ptr ptr long ptr)
 @ stub KeReleaseInterruptSpinLock
 @ stub KeReleaseMutant
 @ stdcall KeReleaseMutex(ptr long)
@@ -670,6 +677,7 @@
 @ stub KeTerminateThread
 @ stdcall KeTestAlertThread(long)
 @ extern KeTickCount
+@ stub KeTryToAcquireGuardedMutex
 @ stdcall KeUnstackDetachProcess(ptr)
 @ stub KeUpdateRunTime
 @ stub KeUpdateSystemTime
@@ -723,9 +731,9 @@
 @ stdcall MmFreeNonCachedMemory(ptr long)
 @ stub MmFreePagesFromMdl
 @ stdcall MmGetPhysicalAddress(ptr)
-@ stub MmGetPhysicalMemoryRanges
+@ stdcall MmGetPhysicalMemoryRanges()
 @ stdcall MmGetSystemRoutineAddress(ptr)
-@ stub MmGetVirtualForPhysical
+@ stdcall MmGetVirtualForPhysical(int64)
 @ stub MmGrowKernelStack
 @ stub MmHighestUserAddress
 @ stdcall MmIsAddressValid(ptr)
@@ -738,6 +746,7 @@
 @ stub MmLockPagableImageSection
 @ stdcall MmLockPagableSectionByHandle(ptr)
 @ stdcall MmMapIoSpace(int64 long long)
+@ stub MmMapIoSpaceEx
 @ stdcall MmMapLockedPages(ptr long)
 @ stdcall MmMapLockedPagesSpecifyCache(ptr long long ptr long long)
 @ stub MmMapLockedPagesWithReservedMapping
@@ -911,33 +920,36 @@
 @ stdcall PsGetCurrentProcessSessionId()
 @ stdcall PsGetCurrentThread() KeGetCurrentThread
 @ stdcall PsGetCurrentThreadId()
+@ stdcall PsGetCurrentThreadTeb()
 @ stub PsGetCurrentThreadPreviousMode
+@ stdcall PsGetCurrentThreadProcess()
+@ stdcall PsGetCurrentThreadProcessId()
 @ stub PsGetCurrentThreadStackBase
 @ stub PsGetCurrentThreadStackLimit
 @ stub PsGetJobLock
 @ stub PsGetJobSessionId
 @ stub PsGetJobUIRestrictionsClass
-@ stub PsGetProcessCreateTimeQuadPart
+@ stdcall PsGetProcessCreateTimeQuadPart(ptr)
 @ stub PsGetProcessDebugPort
-@ stub PsGetProcessExitProcessCalled
-@ stub PsGetProcessExitStatus
+@ stdcall PsGetProcessExitProcessCalled(ptr)
+@ stdcall PsGetProcessExitStatus(ptr)
 @ stub PsGetProcessExitTime
 @ stdcall PsGetProcessId(ptr)
-@ stub PsGetProcessImageFileName
+@ stdcall PsGetProcessImageFileName(ptr)
 @ stdcall PsGetProcessInheritedFromUniqueProcessId(ptr)
 @ stub PsGetProcessJob
-@ stub PsGetProcessPeb
+@ stdcall PsGetProcessPeb(ptr)
 @ stub PsGetProcessPriorityClass
 @ stdcall PsGetProcessSectionBaseAddress(ptr)
 @ stub PsGetProcessSecurityPort
-@ stub PsGetProcessSessionId
+@ stdcall PsGetProcessSessionId(ptr)
 @ stub PsGetProcessWin32Process
 @ stub PsGetProcessWin32WindowStation
 @ stdcall -arch=x86_64 PsGetProcessWow64Process(ptr)
 @ stub PsGetThreadFreezeCount
 @ stub PsGetThreadHardErrorsAreDisabled
 @ stdcall PsGetThreadId(ptr)
-@ stub PsGetThreadProcess
+@ stdcall PsGetThreadProcess(ptr)
 @ stdcall PsGetThreadProcessId(ptr)
 @ stub PsGetThreadSessionId
 @ stub PsGetThreadTeb
@@ -955,7 +967,7 @@
 @ stdcall PsLookupThreadByThreadId(ptr ptr)
 @ extern PsProcessType
 @ stub PsReferenceImpersonationToken
-@ stub PsReferencePrimaryToken
+@ stdcall PsReferencePrimaryToken(ptr)
 @ stdcall PsReferenceProcessFilePointer(ptr ptr)
 @ stdcall PsReleaseProcessExitSynchronization(ptr)
 @ stdcall PsRemoveCreateThreadNotifyRoutine(ptr)
@@ -1362,13 +1374,14 @@
 @ stub SePrivilegeObjectAuditAlarm
 @ stub SePublicDefaultDacl
 @ stub SeQueryAuthenticationIdToken
-@ stub SeQueryInformationToken
+@ stdcall SeQueryInformationToken(ptr long ptr)
 @ stub SeQuerySecurityDescriptorInfo
 @ stub SeQuerySessionIdToken
 @ stub SeRegisterLogonSessionTerminatedRoutine
 @ stub SeReleaseSecurityDescriptor
 @ stub SeReleaseSubjectContext
 @ stub SeSetAccessStateGenericMapping
+@ stub SeSetAuditParameter
 @ stub SeSetSecurityDescriptorInfo
 @ stub SeSetSecurityDescriptorInfoEx
 @ stdcall SeSinglePrivilegeCheck(int64 long)
@@ -1387,6 +1400,7 @@
 @ stub VfFailDriver
 @ stub VfFailSystemBIOS
 @ stub VfIsVerificationEnabled
+@ stdcall VslGetSecurePciEnabled()
 @ stub WRITE_REGISTER_BUFFER_UCHAR
 @ stub WRITE_REGISTER_BUFFER_ULONG
 @ stub WRITE_REGISTER_BUFFER_USHORT
diff --git a/dlls/ntoskrnl.exe/ntoskrnl_private.h b/dlls/ntoskrnl.exe/ntoskrnl_private.h
index d9db6f600ff..013510e64ca 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl_private.h
+++ b/dlls/ntoskrnl.exe/ntoskrnl_private.h
@@ -46,7 +46,8 @@ static inline LPCSTR debugstr_us( const UNICODE_STRING *us )
 
 struct _OBJECT_TYPE
 {
-    const WCHAR *name;            /* object type name used for type validation */
+    LIST_ENTRY entry;             /* dummy list entry to make it windows compliant */
+    UNICODE_STRING name;          /* object type name used for type validation */
     void *(*constructor)(HANDLE); /* used for creating an object from server handle */
     void (*release)(void*);       /* called when the last reference is released */
 };
@@ -55,7 +56,11 @@ struct _EPROCESS
 {
     DISPATCHER_HEADER header;
     PROCESS_BASIC_INFORMATION info;
+    KERNEL_USER_TIMES times;
     BOOL wow64;
+    DWORD session_id;
+    PACCESS_TOKEN token;
+    char imageName[15];
 };
 
 struct _KTHREAD
@@ -72,6 +77,11 @@ struct _ETHREAD
     struct _KTHREAD kthread;
 };
 
+typedef struct _PHYSICAL_MEMORY_RANGE {
+    PHYSICAL_ADDRESS BaseAddress;
+    LARGE_INTEGER NumberOfBytes;
+} PHYSICAL_MEMORY_RANGE, *PPHYSICAL_MEMORY_RANGE;
+
 void *alloc_kernel_object( POBJECT_TYPE type, HANDLE handle, SIZE_T size, LONG ref );
 NTSTATUS kernel_object_from_handle( HANDLE handle, POBJECT_TYPE type, void **ret );
 
diff --git a/dlls/ntoskrnl.exe/pnp.c b/dlls/ntoskrnl.exe/pnp.c
index 9454d94fa3f..686d3ad95c5 100644
--- a/dlls/ntoskrnl.exe/pnp.c
+++ b/dlls/ntoskrnl.exe/pnp.c
@@ -238,7 +238,7 @@ static void load_function_driver( DEVICE_OBJECT *device, HDEVINFO set, SP_DEVINF
     lstrcatW( buffer, driver );
     RtlInitUnicodeString( &string, buffer );
     if (ObReferenceObjectByName( &string, OBJ_CASE_INSENSITIVE, NULL,
-                                 0, NULL, KernelMode, NULL, (void **)&driver_obj ) != STATUS_SUCCESS)
+                                 0, IoDriverObjectType, KernelMode, NULL, (void **)&driver_obj ) != STATUS_SUCCESS)
     {
         ERR("Failed to locate loaded driver %s.\n", debugstr_w(driver));
         return;
diff --git a/dlls/ntoskrnl.exe/sync.c b/dlls/ntoskrnl.exe/sync.c
index 07004733ce3..c3e5b9d5043 100644
--- a/dlls/ntoskrnl.exe/sync.c
+++ b/dlls/ntoskrnl.exe/sync.c
@@ -196,10 +196,9 @@ static void *create_event_object( HANDLE handle )
     return event;
 }
 
-static const WCHAR event_type_name[] = {'E','v','e','n','t',0};
-
 static struct _OBJECT_TYPE event_type = {
-    event_type_name,
+    {},
+    RTL_CONSTANT_STRING( L"Event" ),
     create_event_object
 };
 
@@ -384,11 +383,10 @@ LONG WINAPI KeReleaseSemaphore( PRKSEMAPHORE semaphore, KPRIORITY increment,
     return ret;
 }
 
-static const WCHAR semaphore_type_name[] = {'S','e','m','a','p','h','o','r','e',0};
-
 static struct _OBJECT_TYPE semaphore_type =
 {
-    semaphore_type_name
+    {},
+    RTL_CONSTANT_STRING( L"Semaphore" )
 };
 
 POBJECT_TYPE ExSemaphoreObjectType = &semaphore_type;
@@ -439,6 +437,52 @@ void WINAPI KeInitializeGuardedMutex(PKGUARDED_MUTEX mutex)
     KeInitializeEvent(&mutex->Event, SynchronizationEvent, FALSE);
 }
 
+/***********************************************************************
+ *           KeAcquireGuardedMutexUnsafe   (NTOSKRNL.EXE.@)
+ */
+void WINAPI KeAcquireGuardedMutexUnsafe(PKGUARDED_MUTEX mutex)
+{
+    LONG count;
+
+    TRACE("mutex %p.\n", mutex);
+
+    count = InterlockedDecrement( &mutex->Count );
+    if (count < 0)
+        KeWaitForSingleObject( &mutex->Event, Executive, KernelMode, FALSE, NULL );
+}
+
+/***********************************************************************
+ *           KeAcquireGuardedMutex   (NTOSKRNL.EXE.@)
+ */
+void WINAPI KeAcquireGuardedMutex(PKGUARDED_MUTEX mutex)
+{
+    /* FIXME: Enter Guarded Region */
+    KeAcquireGuardedMutexUnsafe(mutex);
+}
+
+/***********************************************************************
+ *           KeReleaseGuardedMutexUnsafe   (NTOSKRNL.EXE.@)
+ */
+void WINAPI KeReleaseGuardedMutexUnsafe(PKGUARDED_MUTEX mutex)
+{
+    LONG count;
+
+    TRACE("mutex %p.\n", mutex);
+
+    count = InterlockedIncrement( &mutex->Count );
+    if (count < 1)
+        KeSetEvent( &mutex->Event, IO_NO_INCREMENT, FALSE );
+}
+
+/***********************************************************************
+ *           KeReleaseGuardedMutex   (NTOSKRNL.EXE.@)
+ */
+void WINAPI KeReleaseGuardedMutex(PKGUARDED_MUTEX mutex)
+{
+    KeReleaseGuardedMutexUnsafe(mutex);
+    /* FIXME: Leave Guarded Region */
+}
+
 static void CALLBACK ke_timer_complete_proc(PTP_CALLBACK_INSTANCE instance, void *timer_, PTP_TIMER tp_timer)
 {
     KTIMER *timer = timer_;
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 71e83b1c827..659f7655ffb 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5395,6 +5395,22 @@ struct get_kernel_object_handle_reply
 
 
 
+struct get_kernel_object_name_request
+{
+    struct request_header __header;
+    obj_handle_t rootdir;
+    obj_handle_t manager;
+    unsigned int attributes;
+    /* VARARG(name,unicode_str); */
+};
+struct get_kernel_object_name_reply
+{
+    struct reply_header __header;
+    client_ptr_t user_ptr;
+};
+
+
+
 struct make_process_system_request
 {
     struct request_header __header;
@@ -6416,6 +6432,7 @@ enum request
     REQ_grab_kernel_object,
     REQ_release_kernel_object,
     REQ_get_kernel_object_handle,
+    REQ_get_kernel_object_name,
     REQ_make_process_system,
     REQ_grant_process_admin_token,
     REQ_get_token_info,
@@ -6729,6 +6746,7 @@ union generic_request
     struct grab_kernel_object_request grab_kernel_object_request;
     struct release_kernel_object_request release_kernel_object_request;
     struct get_kernel_object_handle_request get_kernel_object_handle_request;
+    struct get_kernel_object_name_request get_kernel_object_name_request;
     struct make_process_system_request make_process_system_request;
     struct grant_process_admin_token_request grant_process_admin_token_request;
     struct get_token_info_request get_token_info_request;
@@ -7040,6 +7058,7 @@ union generic_reply
     struct grab_kernel_object_reply grab_kernel_object_reply;
     struct release_kernel_object_reply release_kernel_object_reply;
     struct get_kernel_object_handle_reply get_kernel_object_handle_reply;
+    struct get_kernel_object_name_reply get_kernel_object_name_reply;
     struct make_process_system_reply make_process_system_reply;
     struct grant_process_admin_token_reply grant_process_admin_token_reply;
     struct get_token_info_reply get_token_info_reply;
diff --git a/server/device.c b/server/device.c
index 3eed74343e5..c7ff9f90986 100644
--- a/server/device.c
+++ b/server/device.c
@@ -1169,3 +1169,31 @@ DECL_HANDLER(get_kernel_object_handle)
 
     release_object( manager );
 }
+
+
+/* get kernel object from object name */
+DECL_HANDLER(get_kernel_object_name)
+{
+    struct device_manager *manager;
+    struct object *obj, *root = NULL;
+    struct unicode_str temp, name = get_req_unicode_str();
+
+    if (!(manager = (struct device_manager *)get_handle_obj( current->process, req->manager,
+        0, &device_manager_ops )))
+        return;
+
+    if (req->rootdir && !(root = get_directory_obj( current->process, req->rootdir )))
+    {
+        release_object( manager );
+        return;
+    }
+
+    if ((obj = lookup_named_object( root, &name, req->attributes, &temp )))
+    {
+        reply->user_ptr = get_kernel_object_ptr( manager, obj );
+        release_object( obj );
+    }
+    else set_error( STATUS_NOT_FOUND );
+
+    release_object( manager );
+}
diff --git a/server/protocol.def b/server/protocol.def
index 1881f0a628a..470236a5c8f 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3810,6 +3810,17 @@ struct handle_info
 @END
 
 
+/* Get kernel pointer from object name */
+@REQ(get_kernel_object_name)
+    obj_handle_t rootdir;         /* root directory */
+    obj_handle_t manager;         /* handle to the device manager */
+    unsigned int attributes;      /* object attributes */
+    VARARG(name,unicode_str);     /* object name */
+@REPLY
+    client_ptr_t user_ptr;        /* kernel object pointer */
+@END
+
+
 /* Make the current process a system process */
 @REQ(make_process_system)
     obj_handle_t handle;          /* handle to the process */
diff --git a/server/request_handlers.h b/server/request_handlers.h
index 399b2789808..d2679d9ef9f 100644
--- a/server/request_handlers.h
+++ b/server/request_handlers.h
@@ -266,6 +266,7 @@ DECL_HANDLER(set_kernel_object_ptr);
 DECL_HANDLER(grab_kernel_object);
 DECL_HANDLER(release_kernel_object);
 DECL_HANDLER(get_kernel_object_handle);
+DECL_HANDLER(get_kernel_object_name);
 DECL_HANDLER(make_process_system);
 DECL_HANDLER(grant_process_admin_token);
 DECL_HANDLER(get_token_info);
@@ -576,6 +577,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_grab_kernel_object,
     (req_handler)req_release_kernel_object,
     (req_handler)req_get_kernel_object_handle,
+    (req_handler)req_get_kernel_object_name,
     (req_handler)req_make_process_system,
     (req_handler)req_grant_process_admin_token,
     (req_handler)req_get_token_info,
@@ -2125,6 +2127,12 @@ C_ASSERT( offsetof(struct get_kernel_object_handle_request, access) == 24 );
 C_ASSERT( sizeof(struct get_kernel_object_handle_request) == 32 );
 C_ASSERT( offsetof(struct get_kernel_object_handle_reply, handle) == 8 );
 C_ASSERT( sizeof(struct get_kernel_object_handle_reply) == 16 );
+C_ASSERT( offsetof(struct get_kernel_object_name_request, rootdir) == 12 );
+C_ASSERT( offsetof(struct get_kernel_object_name_request, manager) == 16 );
+C_ASSERT( offsetof(struct get_kernel_object_name_request, attributes) == 20 );
+C_ASSERT( sizeof(struct get_kernel_object_name_request) == 24 );
+C_ASSERT( offsetof(struct get_kernel_object_name_reply, user_ptr) == 8 );
+C_ASSERT( sizeof(struct get_kernel_object_name_reply) == 16 );
 C_ASSERT( offsetof(struct make_process_system_request, handle) == 12 );
 C_ASSERT( sizeof(struct make_process_system_request) == 16 );
 C_ASSERT( offsetof(struct make_process_system_reply, event) == 8 );
diff --git a/server/request_trace.h b/server/request_trace.h
index 96eebcaa648..70565c83f27 100644
--- a/server/request_trace.h
+++ b/server/request_trace.h
@@ -3018,6 +3018,19 @@ static void dump_get_kernel_object_handle_reply( const struct get_kernel_object_
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
+static void dump_get_kernel_object_name_request( const struct get_kernel_object_name_request *req )
+{
+    fprintf( stderr, " rootdir=%04x", req->rootdir );
+    fprintf( stderr, ", manager=%04x", req->manager );
+    fprintf( stderr, ", attributes=%08x", req->attributes );
+    dump_varargs_unicode_str( ", name=", cur_size );
+}
+
+static void dump_get_kernel_object_name_reply( const struct get_kernel_object_name_reply *req )
+{
+    dump_uint64( " user_ptr=", &req->user_ptr );
+}
+
 static void dump_make_process_system_request( const struct make_process_system_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -3765,6 +3778,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] =
     (dump_func)dump_grab_kernel_object_request,
     (dump_func)dump_release_kernel_object_request,
     (dump_func)dump_get_kernel_object_handle_request,
+    (dump_func)dump_get_kernel_object_name_request,
     (dump_func)dump_make_process_system_request,
     (dump_func)dump_grant_process_admin_token_request,
     (dump_func)dump_get_token_info_request,
@@ -4075,6 +4089,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] =
     NULL,
     NULL,
     (dump_func)dump_get_kernel_object_handle_reply,
+    (dump_func)dump_get_kernel_object_name_reply,
     (dump_func)dump_make_process_system_reply,
     NULL,
     (dump_func)dump_get_token_info_reply,
@@ -4385,6 +4400,7 @@ static const char * const req_names[REQ_NB_REQUESTS] =
     "grab_kernel_object",
     "release_kernel_object",
     "get_kernel_object_handle",
+    "get_kernel_object_name",
     "make_process_system",
     "grant_process_admin_token",
     "get_token_info",
